'use strict';

const assert = require('assert');
const error = require('http-errors');
const fs = require('fs');
const moment = require('moment');
const {promisify} = require('util');
const {sprintf} = require('sprintf-js');
const {spawn} = require('child_process');
const path = require('path');

const readFile = promisify(fs.readFile);

const ASN_1_DATE = 'YYMMDDHHmmss[Z]';
const STATE_VALID = 'valid';
const STATE_REVOKED = 'revoked';
const STATE_MAP = {'V': STATE_VALID, 'R': STATE_REVOKED};


class CpError extends Error {
  constructor(exitCode, message) {
    super("Child process failed with code "+exitCode);
    this.exitCode = exitCode;
  }
}


/**
 * Generate client certificate and certificate key for given name. Optionally encrypt the key with
 * a given passwd.
 *
 * This function is using a file-based locking mechanism - only one certificate can be generated at
 * any given time. Issued certs are registered in index.txt, aiming to be compatible with EasyRSA's
 * revocation mechanism.
 *
 * This is assumed to be sufficiently robust for a small-scale deployment, for larger system a
 * database-backed solution would likely be a better solution.
 */
exports.MkCert = async (config, endpointName, name, passwd=null) => {
  const pkiPath = config.pki.path;
  const indexFile = config.pki.index;
  const paths = certPaths(pkiPath, name);

  const {cacert, cakey} = config.pki;
  const opensslConf = config.openssl.config;
  const keySize = config.endpoints[endpointName].keysize;

  if (await certExists(indexFile, name)) {
    throw error.Conflict(`A valid cert for ${name} already exists`);
  }

  await genReq(name, keySize, opensslConf, passwd, paths);
  await signReq(name, opensslConf, paths);

  return paths;
};


/**
 * Generates an OpenSSL certificate signing request
 */
const genReq = async (cn, keySize, opensslConf, passwd, {pkiPath, keyPath, reqPath}) => {
  const env = {};
  const args = ['req', '-utf8', '-new',
    '-newkey', `rsa:${keySize}`,
    '-config', opensslConf,
    '-keyout', keyPath,
    '-out', reqPath,
    '-batch'
  ];

  if (passwd && passwd.length > 0) {
    // set password via env, avoid exposing it in the logs (still not really save)
    args.push('-passout', 'env:MYPASSWD');
    env.MYPASSWD = passwd;
  } else {
    args.push('-nodes');
  }

  try {
    await execOpensslCmd(args, pkiPath, cn, env);
    console.log('Key written to', keyPath);
    console.log('Req written to', reqPath);
  } catch(err) {
    // re-throw with a more meaningful error message
    throw Error("Error generating CSR, (openssl exit code "+err.exitCode+")");
  }
}


/**
 * Signs an OpenSSL CSR
 */
const signReq = async (cn, opensslConf, {pkiPath, reqPath, certPath}) => {
  const args = ['ca', '-utf8', 
    '-in', reqPath, 
    '-out', certPath,
    '-config', opensslConf, 
    '-batch'
  ];

  try {
    await execOpensslCmd(args, pkiPath, cn);
    console.log('Cert written to', certPath);
  } catch(err) {
    // re-throw with a more meaningful error message
    throw Error("Failed to sign certificate (openssl exit code "+err.exitCode+")");
  }
}


/**
 * Execute a command in the context of the OpenSSL ca generated by easyrsa. Sets up the execution
 * environment to mimic the one provided by the easyrsa tool.
 * 
 * @param {*[]string} args command args
 * @param {*string} pkiPath path to pki initalized by easysa
 * @param {*string} cn common name of the certificate to work with
 */
const execOpensslCmd = (args, pkiPath, cn, env={}) => {
  const cmd = '/usr/bin/openssl';
  // merge default env and env from params (params take precedence)
  const optEnv = Object.assign({
    EASYRSA_PKI: pkiPath,
    EASYRSA_CERT_EXPIRE: '3650',
    EASYRSA_CRL_DAYS: '180',
    EASYRSA_DIGEST: 'sha256',
    EASYRSA_KEY_SIZE: '2048',
    EASYRSA_DN: 'cn_only',
    EASYRSA_REQ_CN: cn,
    EASYRSA_REQ_COUNTRY: 'US',
    EASYRSA_REQ_PROVINCE: 'California',
    EASYRSA_REQ_CITY: 'San Francisco',
    EASYRSA_REQ_ORG: 'Copyleft Certificate Co',
    EASYRSA_REQ_OU: 'My Organizational Unit',
    EASYRSA_REQ_EMAIL: 'me@example.net',
  }, env);

  console.log('Executing',cmd,args.join(' '));

  return new Promise((resolve, reject) => {
    const opts = {env: optEnv};
    const cp = spawn(cmd, args, opts);

    const stdout = [];
    const stderr = [];

    cp.stdout.on('data', b => stdout.push(b));
    cp.stderr.on('data', b => stderr.push(b));

    cp.on('error', err => {
      reject(err);
    });

    cp.on('exit', code => {
      if (code == 0) resolve();
      else {
        console.log(Buffer.concat(stdout).toString('utf-8'));
        console.error(Buffer.concat(stderr).toString('utf-8'));
        reject(new CpError(code));
      }
    });
  });
}


/**
 * List certificates
 * @param {*object} config system config
 */
exports.ListCerts = async (config) => {
  const indexFile = config.pki.index;
  return listCerts(indexFile);
}


/**
 * Load the certs for given entity and return them along with the dh params and ca cert
 * @param {*object} config app config
 * @param {*string} name name of the entity to retrieve certs for
 */
exports.LoadCerts = async (config, name) => {
  const {keyPath, certPath} = certPaths(config.pki.path, name);
  const caPath = config.pki.cacert;
  const dhPath = config.pki.dh;

  const privateKey = await readFile(keyPath, {encoding: 'utf-8'});
  const certificate = await readFile(certPath, {encoding: 'utf-8'});
  const dh = await readFile(dhPath, {encoding: 'utf-8'});
  const ca = await readFile(caPath, {encoding: 'utf-8'});

  return {privateKey, certificate, dh, ca};
}


const certExists = async (indexFile, name) => {
  const certs = await listCerts(indexFile);
  const existing = certs.filter(c => 
    c.name === name && c.state === STATE_VALID && !c.isExpired
  );
  return existing.length > 0;
}


const listCerts = async (indexFile) => {
  const data = await readFile(indexFile, {encoding: 'utf-8'});
  const now = moment();

  return data
    .split("\n")
    .slice(0, -1)
    .map(line => {
      const [st, exp, revk, srl, _4, subject] = line.split("\t");

      // TODO: properly parse X.500 DN?
      const state = STATE_MAP[st];
      const name = subject.match(/\/CN=(\w+)/)[1];
      const expires = moment(exp, ASN_1_DATE);
      const revoked = revk.length > 0 ? moment(revk, ASN_1_DATE) : undefined;
      const isExpired = expires.isBefore(now);
      const serial = parseInt(srl, 16);

      return {state, subject, name, expires, revoked, isExpired, serial};
    })
    .filter(c => c.name != 'server');
}


const validateCerts = (certs) => {
  assert(certs.privateKey, 'Invalid or missing private key');
  assert(certs.publicKey, 'Invalid or missing public key');
  assert(certs.certificate, 'Invalid certificate');
}


/**
 * Generates the file names used to store certificate and private key for given client name based
 * on given easyrsa pki base path.
 */
const certPaths = module.exports.certPaths = (pkiPath, name) => {
  const keyPath = path.join(pkiPath, 'private', name+'.key');
  const certPath = path.join(pkiPath, 'issued', name+'.crt');
  const reqPath = path.join(pkiPath, 'reqs', name+'.csr');
  return {pkiPath, keyPath, certPath, reqPath};
}
